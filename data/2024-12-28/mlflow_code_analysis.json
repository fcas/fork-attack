[
    {
        "number": 44,
        "created_at": "2024-08-15T21:03:44Z",
        "updated_at": "2024-08-19T15:39:24Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/44",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/44",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "java/error-message-exposure",
            "severity": "error",
            "description": "Information exposure through an error message",
            "name": "java/error-message-exposure",
            "tags": [
                "external/cwe/cwe-209",
                "security"
            ],
            "full_description": "Information from an error message propagates to an external user. Error messages can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit.",
            "help": "# Information exposure through an error message\nThe error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the error message entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is sent back to the remote user using the `getMessage()` method. As such, the user is able to see a detailed error message, which may contain sensitive information. In the second version, the error message is logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) {\n\ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// BAD: printing a exception message back to the response\n\t\tresponse.sendError(\n\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n\t\t\tex.getMessage());\n\t\treturn;\n\t}\n\n\ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// GOOD: log the exception message, and send back a non-revealing response\n\t\tlog(\"Exception occurred\", ex.getMessage);\n\t\tresponse.sendError(\n\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n\t\t\t\"Exception occurred\");\n\t\treturn;\n\t}\n}\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* CERT Java Coding Standard: [ERR01-J. Do not allow exceptions to expose sensitive information](https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"java-kotlin\"}",
            "category": "/language:java-kotlin",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "Error information can be exposed to an external user."
            },
            "location": {
                "path": "mlflow/java/scoring/src/main/java/org/mlflow/sagemaker/ScoringServer.java",
                "start_line": 214,
                "end_line": 214,
                "start_column": 38,
                "end_column": 53
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/44/instances"
    },
    {
        "number": 43,
        "created_at": "2024-05-17T18:49:19Z",
        "updated_at": "2024-08-19T15:39:25Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/43",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/43",
        "state": "fixed",
        "fixed_at": "2024-08-19T15:39:22Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "java/stack-trace-exposure",
            "severity": "error",
            "description": "Information exposure through a stack trace",
            "name": "java/stack-trace-exposure",
            "tags": [
                "external/cwe/cwe-209",
                "external/cwe/cwe-497",
                "security"
            ],
            "full_description": "Information from a stack trace propagates to an external user. Stack traces can unintentionally reveal implementation details that are useful to an attacker for developing a subsequent exploit.",
            "help": "# Information exposure through a stack trace\nSoftware developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.\n\nUnfortunately, the same information can be useful to an attacker. The sequence of class names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.\n\n\n## Recommendation\nSend the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.\n\n\n## Example\nIn the following example, an exception is handled in two different ways. In the first version, labeled BAD, the exception is sent back to the remote user using the `sendError()` method. As such, the user is able to see a detailed stack trace, which may contain sensitive information. In the second version, the error message is logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information.\n\n\n```java\nprotected void doGet(HttpServletRequest request, HttpServletResponse response) {\n\ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// BAD: printing a stack trace back to the response\n\t\tex.printStackTrace(response.getWriter());\n\t\treturn;\n\t}\n\n\ttry {\n\t\tdoSomeWork();\n\t} catch (NullPointerException ex) {\n\t\t// GOOD: log the stack trace, and send back a non-revealing response\n\t\tlog(\"Exception occurred\", ex);\n\t\tresponse.sendError(\n\t\t\tHttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n\t\t\t\"Exception occurred\");\n\t\treturn;\n\t}\n}\n\n```\n\n## References\n* OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).\n* CERT Java Coding Standard: [ERR01-J. Do not allow exceptions to expose sensitive information](https://www.securecoding.cert.org/confluence/display/java/ERR01-J.+Do+not+allow+exceptions+to+expose+sensitive+information).\n* Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"java-kotlin\"}",
            "category": "/language:java-kotlin",
            "state": "fixed",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "Error information can be exposed to an external user."
            },
            "location": {
                "path": "mlflow/java/scoring/src/main/java/org/mlflow/sagemaker/ScoringServer.java",
                "start_line": 214,
                "end_line": 214,
                "start_column": 38,
                "end_column": 53
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/43/instances"
    },
    {
        "number": 42,
        "created_at": "2024-05-17T18:46:29Z",
        "updated_at": "2024-05-17T18:46:31Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/42",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/42",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "py/clear-text-logging-sensitive-data",
            "severity": "error",
            "description": "Clear-text logging of sensitive information",
            "name": "py/clear-text-logging-sensitive-data",
            "tags": [
                "external/cwe/cwe-312",
                "external/cwe/cwe-359",
                "external/cwe/cwe-532",
                "security"
            ],
            "full_description": "Logging sensitive information without encryption or hashing can expose it to an attacker.",
            "help": "# Clear-text logging of sensitive information\nIf sensitive data is written to a log entry it could be exposed to an attacker who gains access to the logs.\n\nPotential attackers can obtain sensitive user data when the log output is displayed. Additionally that data may expose system information such as full path names, system information, and sometimes usernames and passwords.\n\n\n## Recommendation\nSensitive data should not be logged.\n\n\n## Example\nIn the example the entire process environment is logged using \\`print\\`. Regular users of the production deployed application should not have access to this much information about the environment configuration.\n\n\n```python\n# BAD: Logging cleartext sensitive data\nimport os\nprint(f\"[INFO] Environment: {os.environ}\")\n```\nIn the second example the data that is logged is not sensitive.\n\n\n```python\nnot_sensitive_data = {'a': 1, 'b': 2}\n# GOOD: it is fine to log data that is not sensitive\nprint(f\"[INFO] Some object contains: {not_sensitive_data}\")\n```\n\n## References\n* OWASP: [Insertion of Sensitive Information into Log File](https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
            "category": "/language:python",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This expression logs sensitive data (secret) as clear text.\nThis expression logs sensitive data (secret) as clear text."
            },
            "location": {
                "path": "mlflow/utils/databricks_utils.py",
                "start_line": 714,
                "end_line": 719,
                "start_column": 17,
                "end_column": 30
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/42/instances"
    },
    {
        "number": 41,
        "created_at": "2024-05-17T18:46:29Z",
        "updated_at": "2024-05-17T18:46:31Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/41",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/41",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "py/clear-text-logging-sensitive-data",
            "severity": "error",
            "description": "Clear-text logging of sensitive information",
            "name": "py/clear-text-logging-sensitive-data",
            "tags": [
                "external/cwe/cwe-312",
                "external/cwe/cwe-359",
                "external/cwe/cwe-532",
                "security"
            ],
            "full_description": "Logging sensitive information without encryption or hashing can expose it to an attacker.",
            "help": "# Clear-text logging of sensitive information\nIf sensitive data is written to a log entry it could be exposed to an attacker who gains access to the logs.\n\nPotential attackers can obtain sensitive user data when the log output is displayed. Additionally that data may expose system information such as full path names, system information, and sometimes usernames and passwords.\n\n\n## Recommendation\nSensitive data should not be logged.\n\n\n## Example\nIn the example the entire process environment is logged using \\`print\\`. Regular users of the production deployed application should not have access to this much information about the environment configuration.\n\n\n```python\n# BAD: Logging cleartext sensitive data\nimport os\nprint(f\"[INFO] Environment: {os.environ}\")\n```\nIn the second example the data that is logged is not sensitive.\n\n\n```python\nnot_sensitive_data = {'a': 1, 'b': 2}\n# GOOD: it is fine to log data that is not sensitive\nprint(f\"[INFO] Some object contains: {not_sensitive_data}\")\n```\n\n## References\n* OWASP: [Insertion of Sensitive Information into Log File](https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
            "category": "/language:python",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This expression logs sensitive data (password) as clear text.\nThis expression logs sensitive data (password) as clear text."
            },
            "location": {
                "path": "mlflow/server/auth/__init__.py",
                "start_line": 660,
                "end_line": 662,
                "start_column": 17,
                "end_column": 46
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/41/instances"
    },
    {
        "number": 40,
        "created_at": "2024-05-17T18:46:29Z",
        "updated_at": "2024-05-17T18:46:31Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/40",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/40",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "py/clear-text-storage-sensitive-data",
            "severity": "error",
            "description": "Clear-text storage of sensitive information",
            "name": "py/clear-text-storage-sensitive-data",
            "tags": [
                "external/cwe/cwe-312",
                "external/cwe/cwe-315",
                "external/cwe/cwe-359",
                "security"
            ],
            "full_description": "Sensitive information stored without encryption or hashing can expose it to an attacker.",
            "help": "# Clear-text storage of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\n\n\n## Example\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\n\n\n```python\nfrom flask import Flask, make_response, request\n\napp = Flask(\"Leak password\")\n\n@app.route('/')\ndef index():\n    password = request.args.get(\"password\")\n    resp = make_response(render_template(...))\n    resp.set_cookie(\"password\", password)\n    return resp\n\n```\nInstead, the credentials should be encrypted, for instance by using the `cryptography` module, or not stored at all.\n\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
            "category": "/language:python",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This expression stores sensitive data (secret) as clear text."
            },
            "location": {
                "path": "mlflow/utils/request_utils.py",
                "start_line": 98,
                "end_line": 98,
                "start_column": 21,
                "end_column": 37
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/40/instances"
    },
    {
        "number": 39,
        "created_at": "2024-05-17T18:46:29Z",
        "updated_at": "2024-05-17T18:46:31Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/39",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/39",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "py/clear-text-storage-sensitive-data",
            "severity": "error",
            "description": "Clear-text storage of sensitive information",
            "name": "py/clear-text-storage-sensitive-data",
            "tags": [
                "external/cwe/cwe-312",
                "external/cwe/cwe-315",
                "external/cwe/cwe-359",
                "security"
            ],
            "full_description": "Sensitive information stored without encryption or hashing can expose it to an attacker.",
            "help": "# Clear-text storage of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\n\n\n## Example\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\n\n\n```python\nfrom flask import Flask, make_response, request\n\napp = Flask(\"Leak password\")\n\n@app.route('/')\ndef index():\n    password = request.args.get(\"password\")\n    resp = make_response(render_template(...))\n    resp.set_cookie(\"password\", password)\n    return resp\n\n```\nInstead, the credentials should be encrypted, for instance by using the `cryptography` module, or not stored at all.\n\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
            "category": "/language:python",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This expression stores sensitive data (secret) as clear text."
            },
            "location": {
                "path": "mlflow/utils/file_utils.py",
                "start_line": 693,
                "end_line": 693,
                "start_column": 35,
                "end_column": 40
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/39/instances"
    },
    {
        "number": 38,
        "created_at": "2024-05-17T18:46:29Z",
        "updated_at": "2024-05-17T18:46:31Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/38",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/38",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "py/clear-text-storage-sensitive-data",
            "severity": "error",
            "description": "Clear-text storage of sensitive information",
            "name": "py/clear-text-storage-sensitive-data",
            "tags": [
                "external/cwe/cwe-312",
                "external/cwe/cwe-315",
                "external/cwe/cwe-359",
                "security"
            ],
            "full_description": "Sensitive information stored without encryption or hashing can expose it to an attacker.",
            "help": "# Clear-text storage of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\n\n\n## Example\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\n\n\n```python\nfrom flask import Flask, make_response, request\n\napp = Flask(\"Leak password\")\n\n@app.route('/')\ndef index():\n    password = request.args.get(\"password\")\n    resp = make_response(render_template(...))\n    resp.set_cookie(\"password\", password)\n    return resp\n\n```\nInstead, the credentials should be encrypted, for instance by using the `cryptography` module, or not stored at all.\n\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
            "category": "/language:python",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This expression stores sensitive data (password) as clear text."
            },
            "location": {
                "path": "mlflow/models/docker_utils.py",
                "start_line": 115,
                "end_line": 124,
                "start_column": 13,
                "end_column": 14
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/38/instances"
    },
    {
        "number": 37,
        "created_at": "2024-05-17T18:46:29Z",
        "updated_at": "2024-05-17T18:46:31Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/37",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/37",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "py/clear-text-storage-sensitive-data",
            "severity": "error",
            "description": "Clear-text storage of sensitive information",
            "name": "py/clear-text-storage-sensitive-data",
            "tags": [
                "external/cwe/cwe-312",
                "external/cwe/cwe-315",
                "external/cwe/cwe-359",
                "security"
            ],
            "full_description": "Sensitive information stored without encryption or hashing can expose it to an attacker.",
            "help": "# Clear-text storage of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\n\n\n## Example\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\n\n\n```python\nfrom flask import Flask, make_response, request\n\napp = Flask(\"Leak password\")\n\n@app.route('/')\ndef index():\n    password = request.args.get(\"password\")\n    resp = make_response(render_template(...))\n    resp.set_cookie(\"password\", password)\n    return resp\n\n```\nInstead, the credentials should be encrypted, for instance by using the `cryptography` module, or not stored at all.\n\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
            "category": "/language:python",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This expression stores sensitive data (password) as clear text.\nThis expression stores sensitive data (password) as clear text.\nThis expression stores sensitive data (password) as clear text."
            },
            "location": {
                "path": "mlflow/utils/credentials.py",
                "start_line": 185,
                "end_line": 185,
                "start_column": 25,
                "end_column": 30
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/37/instances"
    },
    {
        "number": 36,
        "created_at": "2024-05-17T18:46:29Z",
        "updated_at": "2024-05-17T18:46:31Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/36",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/36",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "py/path-injection",
            "severity": "error",
            "description": "Uncontrolled data used in path expression",
            "name": "py/path-injection",
            "tags": [
                "correctness",
                "external/cwe/cwe-022",
                "external/cwe/cwe-023",
                "external/cwe/cwe-036",
                "external/cwe/cwe-073",
                "external/cwe/cwe-099",
                "security"
            ],
            "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
            "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\n\n## Recommendation\nValidate user input before using it to construct a file path, either using an off-the-shelf library function like `werkzeug.utils.secure_filename`, or by performing custom validation.\n\nIdeally, follow these rules:\n\n* Do not allow more than a single \".\" character.\n* Do not allow directory separators such as \"/\" or \"\\\\\" (depending on the file system).\n* Do not rely on simply replacing problematic sequences such as \"../\". For example, after applying this filter to \".../...//\", the resulting string would still be \"../\".\n* Use an allowlist of known good patterns.\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name that is an absolute path, such as `\"/etc/passwd\"`.\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../../etc/passwd\"` will result in the code reading the file located at `\"/server/static/images/../../../etc/passwd\"`, which is the system's password file. This file would then be sent back to the user, giving them access to all the system's passwords. Note that a user could also use an absolute path here, since the result of `os.path.join(\"/server/static/images/\", \"/etc/passwd\")` is `\"/etc/passwd\"`.\n\nIn the third example, the path used to access the file system is normalized *before* being checked against a known prefix. This ensures that regardless of the user input, the resulting path is safe.\n\n\n```python\nimport os.path\nfrom flask import Flask, request, abort\n\napp = Flask(__name__)\n\n@app.route(\"/user_picture1\")\ndef user_picture1():\n    filename = request.args.get('p')\n    # BAD: This could read any file on the file system\n    data = open(filename, 'rb').read()\n    return data\n\n@app.route(\"/user_picture2\")\ndef user_picture2():\n    base_path = '/server/static/images'\n    filename = request.args.get('p')\n    # BAD: This could still read any file on the file system\n    data = open(os.path.join(base_path, filename), 'rb').read()\n    return data\n\n@app.route(\"/user_picture3\")\ndef user_picture3():\n    base_path = '/server/static/images'\n    filename = request.args.get('p')\n    #GOOD -- Verify with normalised version of path\n    fullpath = os.path.normpath(os.path.join(base_path, filename))\n    if not fullpath.startswith(base_path):\n        raise Exception(\"not allowed\")\n    data = open(fullpath, 'rb').read()\n    return data\n\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* npm: [werkzeug.utils.secure_filename](http://werkzeug.pocoo.org/docs/utils/#werkzeug.utils.secure_filename).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
            "category": "/language:python",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This path depends on a user-provided value."
            },
            "location": {
                "path": "mlflow/server/handlers.py",
                "start_line": 1441,
                "end_line": 1441,
                "start_column": 19,
                "end_column": 28
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/36/instances"
    },
    {
        "number": 35,
        "created_at": "2024-05-17T18:46:29Z",
        "updated_at": "2024-05-17T18:46:31Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/35",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/35",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "py/path-injection",
            "severity": "error",
            "description": "Uncontrolled data used in path expression",
            "name": "py/path-injection",
            "tags": [
                "correctness",
                "external/cwe/cwe-022",
                "external/cwe/cwe-023",
                "external/cwe/cwe-036",
                "external/cwe/cwe-073",
                "external/cwe/cwe-099",
                "security"
            ],
            "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
            "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\n\n## Recommendation\nValidate user input before using it to construct a file path, either using an off-the-shelf library function like `werkzeug.utils.secure_filename`, or by performing custom validation.\n\nIdeally, follow these rules:\n\n* Do not allow more than a single \".\" character.\n* Do not allow directory separators such as \"/\" or \"\\\\\" (depending on the file system).\n* Do not rely on simply replacing problematic sequences such as \"../\". For example, after applying this filter to \".../...//\", the resulting string would still be \"../\".\n* Use an allowlist of known good patterns.\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name that is an absolute path, such as `\"/etc/passwd\"`.\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../../etc/passwd\"` will result in the code reading the file located at `\"/server/static/images/../../../etc/passwd\"`, which is the system's password file. This file would then be sent back to the user, giving them access to all the system's passwords. Note that a user could also use an absolute path here, since the result of `os.path.join(\"/server/static/images/\", \"/etc/passwd\")` is `\"/etc/passwd\"`.\n\nIn the third example, the path used to access the file system is normalized *before* being checked against a known prefix. This ensures that regardless of the user input, the resulting path is safe.\n\n\n```python\nimport os.path\nfrom flask import Flask, request, abort\n\napp = Flask(__name__)\n\n@app.route(\"/user_picture1\")\ndef user_picture1():\n    filename = request.args.get('p')\n    # BAD: This could read any file on the file system\n    data = open(filename, 'rb').read()\n    return data\n\n@app.route(\"/user_picture2\")\ndef user_picture2():\n    base_path = '/server/static/images'\n    filename = request.args.get('p')\n    # BAD: This could still read any file on the file system\n    data = open(os.path.join(base_path, filename), 'rb').read()\n    return data\n\n@app.route(\"/user_picture3\")\ndef user_picture3():\n    base_path = '/server/static/images'\n    filename = request.args.get('p')\n    #GOOD -- Verify with normalised version of path\n    fullpath = os.path.normpath(os.path.join(base_path, filename))\n    if not fullpath.startswith(base_path):\n        raise Exception(\"not allowed\")\n    data = open(fullpath, 'rb').read()\n    return data\n\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* npm: [werkzeug.utils.secure_filename](http://werkzeug.pocoo.org/docs/utils/#werkzeug.utils.secure_filename).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
            "category": "/language:python",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This path depends on a user-provided value."
            },
            "location": {
                "path": "mlflow/server/handlers.py",
                "start_line": 1439,
                "end_line": 1439,
                "start_column": 21,
                "end_column": 29
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/35/instances"
    },
    {
        "number": 34,
        "created_at": "2024-05-17T18:46:29Z",
        "updated_at": "2024-05-17T18:46:31Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/34",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/34",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "py/reflective-xss",
            "severity": "error",
            "description": "Reflected server-side cross-site scripting",
            "name": "py/reflective-xss",
            "tags": [
                "external/cwe/cwe-079",
                "external/cwe/cwe-116",
                "security"
            ],
            "full_description": "Writing user input directly to a web page allows for a cross-site scripting vulnerability.",
            "help": "# Reflected server-side cross-site scripting\nDirectly writing user input (for example, an HTTP request parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider escaping the input before writing user input to the page. The standard library provides escaping functions: `html.escape()` for Python 3.2 upwards or `cgi.escape()` older versions of Python. Most frameworks also provide their own escaping functions, for example `flask.escape()`.\n\n\n## Example\nThe following example is a minimal flask app which shows a safe and unsafe way to render the given name back to the page. The first view is unsafe as `first_name` is not escaped, leaving the page vulnerable to cross-site scripting attacks. The second view is safe as `first_name` is escaped, so it is not vulnerable to cross-site scripting attacks.\n\n\n```python\nfrom flask import Flask, request, make_response, escape\n\napp = Flask(__name__)\n\n@app.route('/unsafe')\ndef unsafe():\n    first_name = request.args.get('name', '')\n    return make_response(\"Your name is \" + first_name)\n\n@app.route('/safe')\ndef safe():\n    first_name = request.args.get('name', '')\n    return make_response(\"Your name is \" + escape(first_name))\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Python Library Reference: [html.escape()](https://docs.python.org/3/library/html.html#html.escape).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
            "category": "/language:python",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "Cross-site scripting vulnerability due to a user-provided value."
            },
            "location": {
                "path": "mlflow/server/__init__.py",
                "start_line": 108,
                "end_line": 108,
                "start_column": 12,
                "end_column": 35
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/34/instances"
    },
    {
        "number": 33,
        "created_at": "2024-05-17T18:46:29Z",
        "updated_at": "2024-05-17T18:46:31Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/33",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/33",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "py/bind-socket-all-network-interfaces",
            "severity": "error",
            "description": "Binding a socket to all network interfaces",
            "name": "py/bind-socket-all-network-interfaces",
            "tags": [
                "external/cwe/cwe-200",
                "security"
            ],
            "full_description": "Binding a socket to all interfaces opens it up to traffic from any IPv4 address and is therefore associated with security risks.",
            "help": "# Binding a socket to all network interfaces\nSockets can be used to communicate with other machines on a network. You can use the (IP address, port) pair to define the access restrictions for the socket you create. When using the built-in Python `socket` module (for instance, when building a message sender service or an FTP server data transmitter), one has to bind the port to some interface. When you bind the port to all interfaces using `0.0.0.0` as the IP address, you essentially allow it to accept connections from any IPv4 address provided that it can get to the socket via routing. Binding to all interfaces is therefore associated with security risks.\n\n\n## Recommendation\nBind your service incoming traffic only to a dedicated interface. If you need to bind more than one interface using the built-in `socket` module, create multiple sockets (instead of binding to one socket to all interfaces).\n\n\n## Example\nIn this example, two sockets are insecure because they are bound to all interfaces; one through the `0.0.0.0` notation and another one through an empty string `''`.\n\n\n```python\nimport socket\n\n# binds to all interfaces, insecure\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind(('0.0.0.0', 31137))\n\n# binds to all interfaces, insecure\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind(('', 4040))\n\n# binds only to a dedicated interface, secure\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind(('84.68.10.12', 8080))\n\n```\n\n## References\n* Python reference: [ Socket families](https://docs.python.org/3/library/socket.html#socket-families).\n* Python reference: [ Socket Programming HOWTO](https://docs.python.org/3.7/howto/sockets.html).\n* Common Vulnerabilities and Exposures: [ CVE-2018-1281 Detail](https://nvd.nist.gov/vuln/detail/CVE-2018-1281).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
            "category": "/language:python",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "'' binds a socket to all interfaces."
            },
            "location": {
                "path": "dev/server.py",
                "start_line": 13,
                "end_line": 13,
                "start_column": 9,
                "end_column": 24
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/33/instances"
    },
    {
        "number": 32,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/32",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/32",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at Math.random() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/runs-charts/runs-charts.types.ts",
                "start_line": 72,
                "end_line": 72,
                "start_column": 77,
                "end_column": 81
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/32/instances"
    },
    {
        "number": 31,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/31",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/31",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/runs-charts/components/RunsScatterPlot.tsx",
                "start_line": 86,
                "end_line": 86,
                "start_column": 15,
                "end_column": 53
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/31/instances"
    },
    {
        "number": 30,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/30",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/30",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at Math.random() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/runs-compare/RunsCompare.tsx",
                "start_line": 167,
                "end_line": 167,
                "start_column": 13,
                "end_column": 22
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/30/instances"
    },
    {
        "number": 29,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/29",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/29",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at Math.random() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/runs-charts/runs-charts.types.ts",
                "start_line": 266,
                "end_line": 266,
                "start_column": 54,
                "end_column": 56
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/29/instances"
    },
    {
        "number": 28,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/28",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/28",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at Math.random() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/runs-charts/runs-charts.types.ts",
                "start_line": 174,
                "end_line": 174,
                "start_column": 54,
                "end_column": 56
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/28/instances"
    },
    {
        "number": 27,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/27",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/27",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at Math.random() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/runs-charts/hooks/useRunsChartsUIConfiguration.tsx",
                "start_line": 97,
                "end_line": 97,
                "start_column": 13,
                "end_column": 22
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/27/instances"
    },
    {
        "number": 26,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/26",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/26",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/runs-charts/hooks/useRunsChartsTooltip.stories.tsx",
                "start_line": 81,
                "end_line": 81,
                "start_column": 19,
                "end_column": 42
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/26/instances"
    },
    {
        "number": 25,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/25",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/25",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at Math.random() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/runs-charts/components/sections/RunsChartsSectionAccordion.tsx",
                "start_line": 203,
                "end_line": 203,
                "start_column": 27,
                "end_column": 36
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/25/instances"
    },
    {
        "number": 24,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/24",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/24",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at Math.random() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/runs-charts/components/sections/RunsChartsSectionAccordion.tsx",
                "start_line": 177,
                "end_line": 177,
                "start_column": 44,
                "end_column": 53
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/24/instances"
    },
    {
        "number": 23,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/23",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/23",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/runs-charts/components/RunsScatterPlot.stories.tsx",
                "start_line": 29,
                "end_line": 29,
                "start_column": 19,
                "end_column": 42
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/23/instances"
    },
    {
        "number": 22,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/22",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/22",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/runs-charts/components/RunsScatterPlot.stories.tsx",
                "start_line": 26,
                "end_line": 26,
                "start_column": 13,
                "end_column": 36
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/22/instances"
    },
    {
        "number": 21,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/21",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/21",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/runs-charts/components/RunsMetricsLinePlot.stories.tsx",
                "start_line": 45,
                "end_line": 45,
                "start_column": 19,
                "end_column": 42
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/21/instances"
    },
    {
        "number": 20,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/20",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/20",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/runs-charts/components/RunsMetricsLinePlot.stories.tsx",
                "start_line": 42,
                "end_line": 42,
                "start_column": 13,
                "end_column": 36
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/20/instances"
    },
    {
        "number": 19,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/19",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/19",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/runs-charts/components/RunsMetricsBarPlot.stories.tsx",
                "start_line": 27,
                "end_line": 27,
                "start_column": 19,
                "end_column": 42
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/19/instances"
    },
    {
        "number": 18,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/18",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/18",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/runs-charts/components/RunsMetricsBarPlot.stories.tsx",
                "start_line": 24,
                "end_line": 24,
                "start_column": 13,
                "end_column": 36
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/18/instances"
    },
    {
        "number": 17,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/17",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/17",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/runs-charts/components/RunsContourPlot.stories.tsx",
                "start_line": 29,
                "end_line": 29,
                "start_column": 19,
                "end_column": 42
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/17/instances"
    },
    {
        "number": 16,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/16",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/16",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context.\nThis uses a cryptographically insecure random number generated at randomFn() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/runs-charts/components/RunsContourPlot.stories.tsx",
                "start_line": 26,
                "end_line": 26,
                "start_column": 13,
                "end_column": 36
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/16/instances"
    },
    {
        "number": 15,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/15",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/15",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at Math.random() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/MetricsPlotPanel.tsx",
                "start_line": 299,
                "end_line": 299,
                "start_column": 23,
                "end_column": 32
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/15/instances"
    },
    {
        "number": 14,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/14",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/14",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/insecure-randomness",
            "severity": "warning",
            "description": "Insecure randomness",
            "name": "js/insecure-randomness",
            "tags": [
                "external/cwe/cwe-338",
                "security"
            ],
            "full_description": "Using a cryptographically weak pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
            "help": "# Insecure randomness\nUsing a cryptographically weak pseudo-random number generator to generate a security-sensitive value, such as a password, makes it easier for an attacker to predict the value.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values, the seed. If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a rule of thumb, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes` provides a cryptographically secure pseudo-random byte generator. Note that the conversion from bytes to numbers can introduce bias that breaks the security.\n\nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically secure pseudo-random number generator.\n\n\n## Example\nThe following examples show different ways of generating a password.\n\nIn the first case, we generate a fresh password by appending a random integer to the end of a static string. The random number generator used (`Math.random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated password.\n\n\n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix is not cryptographically secure\n    var suffix = Math.random();\n    var password = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example, a cryptographically secure random number generator is used for the same purpose. In this case, it is much harder to predict the generated integers.\n\n\n```javascript\nfunction securePassword() {\n    // GOOD: the random suffix is cryptographically secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n* NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This uses a cryptographically insecure random number generated at Math.random() in a security context."
            },
            "location": {
                "path": "mlflow/server/js/src/common/utils/ActionUtils.test.ts",
                "start_line": 5,
                "end_line": 5,
                "start_column": 18,
                "end_column": 27
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/14/instances"
    },
    {
        "number": 13,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/13",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/13",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/xss-through-dom",
            "severity": "warning",
            "description": "DOM text reinterpreted as HTML",
            "name": "js/xss-through-dom",
            "tags": [
                "external/cwe/cwe-079",
                "external/cwe/cwe-116",
                "security"
            ],
            "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
            "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
            },
            "location": {
                "path": "docs/theme/mlflow/static/js/custom.js",
                "start_line": 214,
                "end_line": 214,
                "start_column": 30,
                "end_column": 36
            },
            "classifications": [
                "documentation"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/13/instances"
    },
    {
        "number": 12,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/12",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/12",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/double-escaping",
            "severity": "warning",
            "description": "Double escaping or unescaping",
            "name": "js/double-escaping",
            "tags": [
                "correctness",
                "external/cwe/cwe-020",
                "external/cwe/cwe-116",
                "security"
            ],
            "full_description": "When escaping special characters using a meta-character like backslash or ampersand, the meta-character has to be escaped first to avoid double-escaping, and conversely it has to be unescaped last to avoid double-unescaping.",
            "help": "# Double escaping or unescaping\nEscaping meta-characters in untrusted input is an important technique for preventing injection attacks such as cross-site scripting. One particular example of this is HTML entity encoding, where HTML special characters are replaced by HTML character entities to prevent them from being interpreted as HTML markup. For example, the less-than character is encoded as `&lt;` and the double-quote character as `&quot;`. Other examples include backslash-escaping for including untrusted data in string literals and percent-encoding for URI components.\n\nThe reverse process of replacing escape sequences with the characters they represent is known as unescaping.\n\nNote that the escape characters themselves (such as ampersand in the case of HTML encoding) play a special role during escaping and unescaping: they are themselves escaped, but also form part of the escaped representations of other characters. Hence care must be taken to avoid double escaping and unescaping: when escaping, the escape character must be escaped first, when unescaping it has to be unescaped last.\n\nIf used in the context of sanitization, double unescaping may render the sanitization ineffective. Even if it is not used in a security-critical context, it may still result in confusing or garbled output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation. For URI encoding, you can use the standard `encodeURIComponent` and `decodeURIComponent` functions.\n\nOtherwise, make sure to always escape the escape character first, and unescape it last.\n\n\n## Example\nThe following example shows a pair of hand-written HTML encoding and decoding functions:\n\n\n```javascript\nmodule.exports.encode = function(s) {\n  return s.replace(/&/g, \"&amp;\")\n          .replace(/\"/g, \"&quot;\")\n          .replace(/'/g, \"&apos;\");\n};\n\nmodule.exports.decode = function(s) {\n  return s.replace(/&amp;/g, \"&\")\n          .replace(/&quot;/g, \"\\\"\")\n          .replace(/&apos;/g, \"'\");\n};\n\n```\nThe encoding function correctly handles ampersand before the other characters. For example, the string `me & \"you\"` is encoded as `me &amp; &quot;you&quot;`, and the string `&quot;` is encoded as `&amp;quot;`.\n\nThe decoding function, however, incorrectly decodes `&amp;` into `&` before handling the other characters. So while it correctly decodes the first example above, it decodes the second example (`&amp;quot;`) to `\"` (a single double quote), which is not correct.\n\nInstead, the decoding function should decode the ampersand last:\n\n\n```javascript\nmodule.exports.encode = function(s) {\n  return s.replace(/&/g, \"&amp;\")\n          .replace(/\"/g, \"&quot;\")\n          .replace(/'/g, \"&apos;\");\n};\n\nmodule.exports.decode = function(s) {\n  return s.replace(/&quot;/g, \"\\\"\")\n          .replace(/&apos;/g, \"'\")\n          .replace(/&amp;/g, \"&\");\n};\n\n```\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [html-entities](https://www.npmjs.com/package/html-entities) package.\n* npm: [js-string-escape](https://www.npmjs.com/package/js-string-escape) package.\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This replacement may produce '\\\\' characters that are double-unescaped here."
            },
            "location": {
                "path": "mlflow/server/js/public/pdf.worker.js",
                "start_line": 1,
                "end_line": 1,
                "start_column": 188436,
                "end_column": 188484
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/12/instances"
    },
    {
        "number": 11,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/11",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/11",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/incomplete-multi-character-sanitization",
            "severity": "warning",
            "description": "Incomplete multi-character sanitization",
            "name": "js/incomplete-multi-character-sanitization",
            "tags": [
                "correctness",
                "external/cwe/cwe-020",
                "external/cwe/cwe-080",
                "external/cwe/cwe-116",
                "security"
            ],
            "full_description": "A sanitizer that removes a sequence of characters may reintroduce the dangerous sequence.",
            "help": "# Incomplete multi-character sanitization\nSanitizing untrusted input is a common technique for preventing injection attacks and other security vulnerabilities. Regular expressions are often used to perform this sanitization. However, when the regular expression matches multiple consecutive characters, replacing it just once can result in the unsafe text reappearing in the sanitized input.\n\nAttackers can exploit this issue by crafting inputs that, when sanitized with an ineffective regular expression, still contain malicious code or content. This can lead to code execution, data exposure, or other vulnerabilities.\n\n\n## Recommendation\nTo prevent this issue, it is highly recommended to use a well-tested sanitization library whenever possible. These libraries are more likely to handle corner cases and ensure effective sanitization.\n\nIf a library is not an option, you can consider alternative strategies to fix the issue. For example, applying the regular expression replacement repeatedly until no more replacements can be performed, or rewriting the regular expression to match single characters instead of the entire unsafe text.\n\n\n## Example\nConsider the following JavaScript code that aims to remove all HTML comment start and end tags:\n\n```javascript\n\nstr.replace(/<!--|--!?>/g, \"\");   \n\n```\nGiven the input string \"&lt;!&lt;!--- comment ---&gt;&gt;\", the output will be \"&lt;!-- comment --&gt;\", which still contains an HTML comment.\n\nOne possible fix for this issue is to apply the regular expression replacement repeatedly until no more replacements can be performed. This ensures that the unsafe text does not re-appear in the sanitized input, effectively removing all instances of the targeted pattern:\n\n```javascript\n\nfunction removeHtmlComments(input) {  \n  let previous;  \n  do {  \n    previous = input;  \n    input = input.replace(/<!--|--!?>/g, \"\");  \n  } while (input !== previous);  \n  return input;  \n}  \n\n```\n\n## Example\nAnother example is the following regular expression intended to remove script tags:\n\n```javascript\n\nstr.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/g, \"\");  \n\n```\nIf the input string is \"&lt;scrip&lt;script&gt;is removed&lt;/script&gt;t&gt;alert(123)&lt;/script&gt;\", the output will be \"&lt;script&gt;alert(123)&lt;/script&gt;\", which still contains a script tag.\n\nA fix for this issue is to rewrite the regular expression to match single characters (\"&lt;\" and \"&gt;\") instead of the entire unsafe text. This simplifies the sanitization process and ensures that all potentially unsafe characters are removed:\n\n```javascript\n\nfunction removeAllHtmlTags(input) {  \n  return input.replace(/<|>/g, \"\");  \n}\n\n```\nAnother potential fix is to use the popular `sanitize-html` npm library. It keeps most of the safe HTML tags while removing all unsafe tags and attributes.\n\n```javascript\n\nconst sanitizeHtml = require(\"sanitize-html\");\nfunction removeAllHtmlTags(input) {  \n  return sanitizeHtml(input);  \n}\n\n```\n\n## Example\nLastly, consider a path sanitizer using the regular expression `/\\.\\.\\//`:\n\n```javascript\n\nstr.replace(/\\.\\.\\//g, \"\");  \n\n```\nThe regular expression attempts to strip out all occurences of `/../` from `str`. This will not work as expected: for the string `/./.././`, for example, it will remove the single occurrence of `/../` in the middle, but the remainder of the string then becomes `/../`, which is another instance of the substring we were trying to remove.\n\nA possible fix for this issue is to use the \"sanitize-filename\" npm library for path sanitization. This library is specifically designed to handle path sanitization, and should handle all corner cases and ensure effective sanitization:\n\n```javascript\n\nconst sanitize = require(\"sanitize-filename\");  \n  \nfunction sanitizePath(input) {  \n  return sanitize(input);  \n}  \n\n```\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* Stack Overflow: [Removing all script tags from HTML with JS regular expression](https://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This string may still contain <script, which may cause an HTML element injection vulnerability."
            },
            "location": {
                "path": "mlflow/server/js/src/common/utils/ErrorWrapper.ts",
                "start_line": 55,
                "end_line": 55,
                "start_column": 28,
                "end_column": 62
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/11/instances"
    },
    {
        "number": 10,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/10",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/10",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/incomplete-sanitization",
            "severity": "warning",
            "description": "Incomplete string escaping or encoding",
            "name": "js/incomplete-sanitization",
            "tags": [
                "correctness",
                "external/cwe/cwe-020",
                "external/cwe/cwe-080",
                "external/cwe/cwe-116",
                "security"
            ],
            "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
            "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This replaces only the first occurrence of \"*\"."
            },
            "location": {
                "path": "mlflow/server/js/yarn/releases/yarn-3.5.0.cjs",
                "start_line": 635,
                "end_line": 635,
                "start_column": 2333,
                "end_column": 2342
            },
            "classifications": [
                "library"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/10/instances"
    },
    {
        "number": 9,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/9",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/9",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/incomplete-sanitization",
            "severity": "warning",
            "description": "Incomplete string escaping or encoding",
            "name": "js/incomplete-sanitization",
            "tags": [
                "correctness",
                "external/cwe/cwe-020",
                "external/cwe/cwe-080",
                "external/cwe/cwe-116",
                "security"
            ],
            "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
            "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This replaces only the first occurrence of '\"'."
            },
            "location": {
                "path": "mlflow/server/js/yarn/releases/yarn-3.5.0.cjs",
                "start_line": 412,
                "end_line": 412,
                "start_column": 1292,
                "end_column": 1301
            },
            "classifications": [
                "library"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/9/instances"
    },
    {
        "number": 8,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/8",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/8",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/incomplete-sanitization",
            "severity": "warning",
            "description": "Incomplete string escaping or encoding",
            "name": "js/incomplete-sanitization",
            "tags": [
                "correctness",
                "external/cwe/cwe-020",
                "external/cwe/cwe-080",
                "external/cwe/cwe-116",
                "security"
            ],
            "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
            "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This replaces only the first occurrence of '\"'."
            },
            "location": {
                "path": "mlflow/server/js/yarn/releases/yarn-3.6.3.cjs",
                "start_line": 412,
                "end_line": 412,
                "start_column": 1292,
                "end_column": 1301
            },
            "classifications": [
                "library"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/8/instances"
    },
    {
        "number": 7,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/7",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/7",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/incomplete-sanitization",
            "severity": "warning",
            "description": "Incomplete string escaping or encoding",
            "name": "js/incomplete-sanitization",
            "tags": [
                "correctness",
                "external/cwe/cwe-020",
                "external/cwe/cwe-080",
                "external/cwe/cwe-116",
                "security"
            ],
            "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
            "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "This does not escape backslash characters in the input."
            },
            "location": {
                "path": "mlflow/server/js/src/experiment-tracking/components/run-page/RunViewOverview.tsx",
                "start_line": 553,
                "end_line": 553,
                "start_column": 18,
                "end_column": 29
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/7/instances"
    },
    {
        "number": 6,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/6",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/6",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/overly-large-range",
            "severity": "warning",
            "description": "Overly permissive regular expression range",
            "name": "js/overly-large-range",
            "tags": [
                "correctness",
                "external/cwe/cwe-020",
                "security"
            ],
            "full_description": "Overly permissive regular expression ranges match a wider range of characters than intended. This may allow an attacker to bypass a filter or sanitizer.",
            "help": "# Overly permissive regular expression range\nIt's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \\ ] ^ _ ` ``.\n\nAnother common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.\n\n\n## Recommendation\nAvoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.\n\n\n## Example\nThe following example code is intended to check whether a string is a valid 6 digit hex color.\n\n```javascript\n\nfunction isValidHexColor(color) {\n    return /^#[0-9a-fA-f]{6}$/i.test(color);\n}\n\n```\nHowever, the `A-f` range is overly large and matches every uppercase character. It would parse a \"color\" like `#XXYYZZ` as valid.\n\nThe fix is to use an uppercase `A-F` range instead.\n\n```javascript\n\nfunction isValidHexColor(color) {\n    return /^#[0-9A-F]{6}$/i.test(color);\n}\n\n```\n\n## References\n* GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)\n* wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)\n* Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)\n* Paul Boyd: [The regex \\[,-.\\]](https://pboyd.io/posts/comma-dash-dot/)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "Suspicious character range that is equivalent to \\[0-9:;<=>?@A-Z\\\\\\[\\\\\\\\\\\\\\]^_`a-z\\]."
            },
            "location": {
                "path": "mlflow/server/js/yarn/releases/yarn-3.5.0.cjs",
                "start_line": 190,
                "end_line": 190,
                "start_column": 66833,
                "end_column": 66836
            },
            "classifications": [
                "library"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/6/instances"
    },
    {
        "number": 5,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/5",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/5",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/overly-large-range",
            "severity": "warning",
            "description": "Overly permissive regular expression range",
            "name": "js/overly-large-range",
            "tags": [
                "correctness",
                "external/cwe/cwe-020",
                "security"
            ],
            "full_description": "Overly permissive regular expression ranges match a wider range of characters than intended. This may allow an attacker to bypass a filter or sanitizer.",
            "help": "# Overly permissive regular expression range\nIt's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \\ ] ^ _ ` ``.\n\nAnother common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.\n\n\n## Recommendation\nAvoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.\n\n\n## Example\nThe following example code is intended to check whether a string is a valid 6 digit hex color.\n\n```javascript\n\nfunction isValidHexColor(color) {\n    return /^#[0-9a-fA-f]{6}$/i.test(color);\n}\n\n```\nHowever, the `A-f` range is overly large and matches every uppercase character. It would parse a \"color\" like `#XXYYZZ` as valid.\n\nThe fix is to use an uppercase `A-F` range instead.\n\n```javascript\n\nfunction isValidHexColor(color) {\n    return /^#[0-9A-F]{6}$/i.test(color);\n}\n\n```\n\n## References\n* GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)\n* wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)\n* Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)\n* Paul Boyd: [The regex \\[,-.\\]](https://pboyd.io/posts/comma-dash-dot/)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "Suspicious character range that is equivalent to \\[0-9:;<=>?@A-Z\\\\\\[\\\\\\\\\\\\\\]^_`a-z\\]."
            },
            "location": {
                "path": "mlflow/server/js/yarn/releases/yarn-3.5.0.cjs",
                "start_line": 190,
                "end_line": 190,
                "start_column": 66825,
                "end_column": 66828
            },
            "classifications": [
                "library"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/5/instances"
    },
    {
        "number": 4,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/4",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/4",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/overly-large-range",
            "severity": "warning",
            "description": "Overly permissive regular expression range",
            "name": "js/overly-large-range",
            "tags": [
                "correctness",
                "external/cwe/cwe-020",
                "security"
            ],
            "full_description": "Overly permissive regular expression ranges match a wider range of characters than intended. This may allow an attacker to bypass a filter or sanitizer.",
            "help": "# Overly permissive regular expression range\nIt's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \\ ] ^ _ ` ``.\n\nAnother common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.\n\n\n## Recommendation\nAvoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.\n\n\n## Example\nThe following example code is intended to check whether a string is a valid 6 digit hex color.\n\n```javascript\n\nfunction isValidHexColor(color) {\n    return /^#[0-9a-fA-f]{6}$/i.test(color);\n}\n\n```\nHowever, the `A-f` range is overly large and matches every uppercase character. It would parse a \"color\" like `#XXYYZZ` as valid.\n\nThe fix is to use an uppercase `A-F` range instead.\n\n```javascript\n\nfunction isValidHexColor(color) {\n    return /^#[0-9A-F]{6}$/i.test(color);\n}\n\n```\n\n## References\n* GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)\n* wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)\n* Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)\n* Paul Boyd: [The regex \\[,-.\\]](https://pboyd.io/posts/comma-dash-dot/)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "Suspicious character range that is equivalent to \\[0-9:;<=>?@A-Z\\\\\\[\\\\\\\\\\\\\\]^_`a-z\\]."
            },
            "location": {
                "path": "mlflow/server/js/yarn/releases/yarn-3.6.3.cjs",
                "start_line": 190,
                "end_line": 190,
                "start_column": 66833,
                "end_column": 66836
            },
            "classifications": [
                "library"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/4/instances"
    },
    {
        "number": 3,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/3",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/3",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/overly-large-range",
            "severity": "warning",
            "description": "Overly permissive regular expression range",
            "name": "js/overly-large-range",
            "tags": [
                "correctness",
                "external/cwe/cwe-020",
                "security"
            ],
            "full_description": "Overly permissive regular expression ranges match a wider range of characters than intended. This may allow an attacker to bypass a filter or sanitizer.",
            "help": "# Overly permissive regular expression range\nIt's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \\ ] ^ _ ` ``.\n\nAnother common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.\n\n\n## Recommendation\nAvoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.\n\n\n## Example\nThe following example code is intended to check whether a string is a valid 6 digit hex color.\n\n```javascript\n\nfunction isValidHexColor(color) {\n    return /^#[0-9a-fA-f]{6}$/i.test(color);\n}\n\n```\nHowever, the `A-f` range is overly large and matches every uppercase character. It would parse a \"color\" like `#XXYYZZ` as valid.\n\nThe fix is to use an uppercase `A-F` range instead.\n\n```javascript\n\nfunction isValidHexColor(color) {\n    return /^#[0-9A-F]{6}$/i.test(color);\n}\n\n```\n\n## References\n* GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)\n* wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)\n* Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)\n* Paul Boyd: [The regex \\[,-.\\]](https://pboyd.io/posts/comma-dash-dot/)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "Suspicious character range that is equivalent to \\[0-9:;<=>?@A-Z\\\\\\[\\\\\\\\\\\\\\]^_`a-z\\]."
            },
            "location": {
                "path": "mlflow/server/js/yarn/releases/yarn-3.6.3.cjs",
                "start_line": 190,
                "end_line": 190,
                "start_column": 66825,
                "end_column": 66828
            },
            "classifications": [
                "library"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/3/instances"
    },
    {
        "number": 2,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/2",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/2",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/overly-large-range",
            "severity": "warning",
            "description": "Overly permissive regular expression range",
            "name": "js/overly-large-range",
            "tags": [
                "correctness",
                "external/cwe/cwe-020",
                "security"
            ],
            "full_description": "Overly permissive regular expression ranges match a wider range of characters than intended. This may allow an attacker to bypass a filter or sanitizer.",
            "help": "# Overly permissive regular expression range\nIt's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \\ ] ^ _ ` ``.\n\nAnother common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.\n\n\n## Recommendation\nAvoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.\n\n\n## Example\nThe following example code is intended to check whether a string is a valid 6 digit hex color.\n\n```javascript\n\nfunction isValidHexColor(color) {\n    return /^#[0-9a-fA-f]{6}$/i.test(color);\n}\n\n```\nHowever, the `A-f` range is overly large and matches every uppercase character. It would parse a \"color\" like `#XXYYZZ` as valid.\n\nThe fix is to use an uppercase `A-F` range instead.\n\n```javascript\n\nfunction isValidHexColor(color) {\n    return /^#[0-9A-F]{6}$/i.test(color);\n}\n\n```\n\n## References\n* GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)\n* wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)\n* Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)\n* Paul Boyd: [The regex \\[,-.\\]](https://pboyd.io/posts/comma-dash-dot/)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "Suspicious character range that overlaps with a-f in the same character class, and is equivalent to \\[A-Z\\\\\\[\\\\\\\\\\\\\\]^_`a-f\\]."
            },
            "location": {
                "path": "mlflow/server/js/yarn/releases/yarn-3.5.0.cjs",
                "start_line": 7,
                "end_line": 7,
                "start_column": 445,
                "end_column": 448
            },
            "classifications": [
                "library"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/2/instances"
    },
    {
        "number": 1,
        "created_at": "2024-05-17T18:46:20Z",
        "updated_at": "2024-05-17T18:46:22Z",
        "url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/1",
        "html_url": "https://github.com/fcas/mlflow/security/code-scanning/1",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "js/overly-large-range",
            "severity": "warning",
            "description": "Overly permissive regular expression range",
            "name": "js/overly-large-range",
            "tags": [
                "correctness",
                "external/cwe/cwe-020",
                "security"
            ],
            "full_description": "Overly permissive regular expression ranges match a wider range of characters than intended. This may allow an attacker to bypass a filter or sanitizer.",
            "help": "# Overly permissive regular expression range\nIt's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \\ ] ^ _ ` ``.\n\nAnother common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.\n\n\n## Recommendation\nAvoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.\n\n\n## Example\nThe following example code is intended to check whether a string is a valid 6 digit hex color.\n\n```javascript\n\nfunction isValidHexColor(color) {\n    return /^#[0-9a-fA-f]{6}$/i.test(color);\n}\n\n```\nHowever, the `A-f` range is overly large and matches every uppercase character. It would parse a \"color\" like `#XXYYZZ` as valid.\n\nThe fix is to use an uppercase `A-F` range instead.\n\n```javascript\n\nfunction isValidHexColor(color) {\n    return /^#[0-9A-F]{6}$/i.test(color);\n}\n\n```\n\n## References\n* GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)\n* wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)\n* Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)\n* Paul Boyd: [The regex \\[,-.\\]](https://pboyd.io/posts/comma-dash-dot/)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.19.2"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
            "category": "/language:javascript-typescript",
            "state": "open",
            "commit_sha": "5eaf0680f5e6488e4b16db2100ee9eb9e4979a79",
            "message": {
                "text": "Suspicious character range that overlaps with a-f in the same character class, and is equivalent to \\[A-Z\\\\\\[\\\\\\\\\\\\\\]^_`a-f\\]."
            },
            "location": {
                "path": "mlflow/server/js/yarn/releases/yarn-3.6.3.cjs",
                "start_line": 7,
                "end_line": 7,
                "start_column": 445,
                "end_column": 448
            },
            "classifications": [
                "library"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/mlflow/code-scanning/alerts/1/instances"
    }
]