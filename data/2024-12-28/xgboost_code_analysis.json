[
    {
        "number": 66,
        "created_at": "2024-05-19T02:18:53Z",
        "updated_at": "2024-05-19T02:18:55Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/66",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/66",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: GitHub-owned GitHubAction not pinned by hash\nRemediation tip: update your workflow using [https://app.stepsecurity.io](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/codeql.yml/master?enable=pin)\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/codeql.yml",
                "start_line": 91,
                "end_line": 91,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/66/instances"
    },
    {
        "number": 65,
        "created_at": "2024-05-19T02:18:53Z",
        "updated_at": "2024-05-19T02:18:55Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/65",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/65",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: GitHub-owned GitHubAction not pinned by hash\nRemediation tip: update your workflow using [https://app.stepsecurity.io](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/codeql.yml/master?enable=pin)\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/codeql.yml",
                "start_line": 59,
                "end_line": 59,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/65/instances"
    },
    {
        "number": 64,
        "created_at": "2024-05-17T21:04:13Z",
        "updated_at": "2024-05-17T21:04:15Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/64",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/64",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "py/clear-text-logging-sensitive-data",
            "severity": "error",
            "description": "Clear-text logging of sensitive information",
            "name": "py/clear-text-logging-sensitive-data",
            "tags": [
                "external/cwe/cwe-312",
                "external/cwe/cwe-359",
                "external/cwe/cwe-532",
                "security"
            ],
            "full_description": "Logging sensitive information without encryption or hashing can expose it to an attacker.",
            "help": "# Clear-text logging of sensitive information\nIf sensitive data is written to a log entry it could be exposed to an attacker who gains access to the logs.\n\nPotential attackers can obtain sensitive user data when the log output is displayed. Additionally that data may expose system information such as full path names, system information, and sometimes usernames and passwords.\n\n\n## Recommendation\nSensitive data should not be logged.\n\n\n## Example\nIn the example the entire process environment is logged using \\`print\\`. Regular users of the production deployed application should not have access to this much information about the environment configuration.\n\n\n```python\n# BAD: Logging cleartext sensitive data\nimport os\nprint(f\"[INFO] Environment: {os.environ}\")\n```\nIn the second example the data that is logged is not sensitive.\n\n\n```python\nnot_sensitive_data = {'a': 1, 'b': 2}\n# GOOD: it is fine to log data that is not sensitive\nprint(f\"[INFO] Some object contains: {not_sensitive_data}\")\n```\n\n## References\n* OWASP: [Insertion of Sensitive Information into Log File](https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "CodeQL",
            "guid": null,
            "version": "2.18.0"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/codeql.yml:analyze",
            "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
            "category": "/language:python",
            "state": "open",
            "commit_sha": "dc55c46865acd569f107bfff0b126c08679961ae",
            "message": {
                "text": "This expression logs sensitive data (secret) as clear text."
            },
            "location": {
                "path": "tests/buildkite/infrastructure/service-user/create_service_user.py",
                "start_line": 34,
                "end_line": 34,
                "start_column": 11,
                "end_column": 68
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/64/instances"
    },
    {
        "number": 63,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/63",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/63",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "MaintainedID",
            "severity": "error",
            "description": "Maintained",
            "name": "Maintained",
            "tags": [
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project is \"actively maintained\".",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- There is no remediation work needed from projects with a low score; this check simply provides insight into the project activity and maintenance commitment. External users should determine whether the software is the type that would not normally need active maintenance.\n\n\n\n**Severity**: High\n\n\n\n**Details**:\n\nRisk: `High` (possibly unpatched vulnerabilities)\n\n\n\nThis check determines whether the project is actively maintained. If the project\n\nis archived, it receives the lowest score. If there is at least one commit per\n\nweek during the previous 90 days, the project receives the highest score.  If there\n\nis activity on issues from users who are collaborators, members, or owners of the\n\nproject, the project receives a partial score.\n\n\n\nA project which is not active might not be patched, have its\n\ndependencies patched, or be actively tested and used. However, a lack\n\nof active maintenance is not necessarily always a problem. Some software,\n\nespecially smaller utility functions, does not normally need to be maintained.\n\nFor example, a library that determines if an integer is even would not normally\n\nneed maintenance unless an underlying implementation language definition\n\nchanged. A lack of active maintenance should signal that potential users should\n\ninvestigate further to judge the situation.\n\n\n\nThis check will only succeed if a Github project is >90 days old. Projects\n\nthat are younger than this are too new to assess whether they are maintained\n\nor not, and users should inspect the contents of those projects to ensure they\n\nare as expected.\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#maintained",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/online-scm",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: repo was created 2 days ago, not enough maintenance history:\nWarn: repo was created in the last 90 days (Created at: 2024-05-16T23:15:05Z), please review its contents carefully\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "no file associated with this alert",
                "start_line": 1,
                "end_line": 1,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/63/instances"
    },
    {
        "number": 62,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/62",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/62",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "FuzzingID",
            "severity": "error",
            "description": "Fuzzing",
            "name": "Fuzzing",
            "tags": [
                "security",
                "supply-chain",
                "testing"
            ],
            "full_description": "Determines if the project uses fuzzing.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- Integrate the project with OSS-Fuzz by following the instructions [here](https://google.github.io/oss-fuzz/).\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible vulnerabilities in code)\n\n\n\nThis check tries to determine if the project uses\n\n[fuzzing](https://owasp.org/www-community/Fuzzing) by checking:\n\n1. if the repository name is included in the [OSS-Fuzz](https://github.com/google/oss-fuzz) project list;\n\n2. if [ClusterFuzzLite](https://google.github.io/clusterfuzzlite/) is deployed in the repository;\n\n3. if there are user-defined language-specified fuzzing functions in the repository.\n\n   - currently only supports [Go fuzzing](https://go.dev/doc/fuzz/),\n\n   - a limited set of property-based testing libraries for Haskell including [QuickCheck](https://hackage.haskell.org/package/QuickCheck), [Hedgehog](https://hedgehog.qa/), [validity](https://hackage.haskell.org/package/validity) or [SmallCheck](https://hackage.haskell.org/package/smallcheck),\n\n   - a limited set of property-based testing libraries for JavaScript and TypeScript including [fast-check](https://fast-check.dev/).\n\n4. if it contains a [OneFuzz](https://github.com/microsoft/onefuzz) integration [detection file](https://github.com/microsoft/onefuzz/blob/main/docs/getting-started.md#detecting-the-use-of-onefuzz);\n\n\n\nFuzzing, or fuzz testing, is the practice of feeding unexpected or random data\n\ninto a program to expose bugs. Regular fuzzing is important to detect\n\nvulnerabilities that may be exploited by others, especially since attackers can\n\nalso use fuzzing to find the same flaws.\n\n\n\nNote: A project that fulfills this criterion with other tools may still receive\n\na low score on this test. There are many ways to implement fuzzing, and it is\n\nchallenging for an automated tool like Scorecard to detect them all. A low score\n\nis therefore not a definitive indication that the project is at risk.\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#fuzzing",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/online-scm",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: project is not fuzzed:\nWarn: no OSSFuzz integration found: Follow the steps in https://github.com/google/oss-fuzz to integrate fuzzing for your project.\nOver time, try to add fuzzing for more functionalities of your project. (High effort)\nWarn: no OneFuzz integration found: Follow the steps in https://github.com/microsoft/onefuzz to start fuzzing for your project.\nOver time, try to add fuzzing for more functionalities of your project. (High effort)\nWarn: no GoBuiltInFuzzer integration found: Follow the steps in https://go.dev/doc/fuzz/ to enable fuzzing on your project.\nOver time, try to add fuzzing for more functionalities of your project. (Medium effort)\nWarn: no PythonAtherisFuzzer integration found: Follow the steps in https://github.com/google/atheris to enable fuzzing on your project.\nOver time, try to add fuzzing for more functionalities of your project. (Medium effort)\nWarn: no CLibFuzzer integration found: Follow the steps in https://llvm.org/docs/LibFuzzer.html to enable fuzzing on your project.\nOver time, try to add fuzzing for more functionalities of your project. (Medium effort)\nWarn: no CppLibFuzzer integration found: Follow the steps in https://llvm.org/docs/LibFuzzer.html to enable fuzzing on your project.\nOver time, try to add fuzzing for more functionalities of your project. (Medium effort)\nWarn: no SwiftLibFuzzer integration found: Follow the steps in https://google.github.io/oss-fuzz/getting-started/new-project-guide/swift-lang/ to enable fuzzing on your project.\nOver time, try to add fuzzing for more functionalities of your project. (Medium effort)\nWarn: no RustCargoFuzzer integration found: Follow the steps in https://rust-fuzz.github.io/book/cargo-fuzz.html to enable fuzzing on your project.\nOver time, try to add fuzzing for more functionalities of your project. (Medium effort)\nWarn: no JavaJazzerFuzzer integration found: Follow the steps in https://github.com/CodeIntelligenceTesting/jazzer to enable fuzzing on your project.\nOver time, try to add fuzzing for more functionalities of your project. (Medium effort)\nWarn: no ClusterFuzzLite integration found: Follow the steps in https://github.com/google/clusterfuzzlite to integrate fuzzing as part of CI.\nOver time, try to add fuzzing for more functionalities of your project. (High effort)\nWarn: no HaskellPropertyBasedTesting integration found: Use one of the following frameworks to fuzz your project:\nQuickCheck: https://hackage.haskell.org/package/QuickCheck\nhedgehog: https://hedgehog.qa/\nvalidity: https://github.com/NorfairKing/validity\nsmallcheck: https://hackage.haskell.org/package/smallcheck\nhspec: https://hspec.github.io/\ntasty: https://hackage.haskell.org/package/tasty (High effort)\nWarn: no TypeScriptPropertyBasedTesting integration found: Use fast-check: https://github.com/dubzzz/fast-check (High effort)\nWarn: no JavaScriptPropertyBasedTesting integration found: Use fast-check: https://github.com/dubzzz/fast-check (High effort)\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "no file associated with this alert",
                "start_line": 1,
                "end_line": 1,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/62/instances"
    },
    {
        "number": 61,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/61",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/61",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "CodeReviewID",
            "severity": "error",
            "description": "Code-Review",
            "name": "Code-Review",
            "tags": [
                "code-reviews",
                "security",
                "source-code",
                "supply-chain"
            ],
            "full_description": "Determines if the project requires human code review before pull requests (aka merge requests) are merged.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If the project has only one contributor, or does not have enough reviewers to practically require that all contributions be reviewed, try to recruit more maintainers to the project who will be willing to review others' work. Ideally at least some of these people will be from different organizations (see [Contributors](checks.md#contributors)). If the project has very limited utility, consider expanding its intended utility so more people will be interested in improving it, and make that larger scope clear to potential contributors.\n\n- Follow security best practices by performing strict code reviews for every new pull request / merge request.\n\n- Make \"code reviews\" mandatory in your repository configuration. ([Instructions for GitHub.](https://docs.github.com/en/github/administering-a-repository/about-protected-branches#require-pull-request-reviews-before-merging))\n\n- Enforce the rule for administrators / code owners as well. ([Instructions for GitHub.](https://docs.github.com/en/github/administering-a-repository/about-protected-branches#include-administrators))\n\n\n\n**Severity**: High\n\n\n\n**Details**:\n\nRisk: `High` (unintentional vulnerabilities or possible injection of malicious\n\ncode)\n\n\n\nThis check determines whether the project requires human code review\n\nbefore pull requests (merge requests) are merged.\n\n\n\nReviews detect various unintentional problems, including vulnerabilities that\n\ncan be fixed immediately before they are merged, which improves the quality of\n\nthe code. Reviews may also detect or deter an attacker trying to insert\n\nmalicious code (either as a malicious contributor or as an attacker who has\n\nsubverted a contributor's account), because a reviewer might detect the\n\nsubversion.\n\n\n\nThe check determines whether the most recent changes (over the last ~30 commits) have \n\nan approval on GitHub\n\nor if the merger is different from the committer (implicit review). It also\n\nperforms a similar check for reviews using\n\n[Prow](https://github.com/kubernetes/test-infra/tree/master/prow#readme) (labels\n\n\"lgtm\" or \"approved\") and [Gerrit](https://www.gerritcodereview.com/) (\"Reviewed-on\" and \"Reviewed-by\").\n\nIf recent changes are solely bot activity (e.g. Dependabot, Renovate bot, or custom bots),\n\nthe check returns inconclusively.\n\n\n\nScoring is leveled instead of proportional to make the check more predictable.\n\nIf any bot-originated changes are unreviewed, 3 points are deducted. If any human\n\nchanges are unreviewed, 7 points are deducted if a single change is unreviewed, and\n\nanother 3 are deducted if multiple changes are unreviewed.\n\n\n\nReview by bots, including bots powered by\n\nartificial intelligence / machine learning (AI/ML),\n\ndo not count as code review.\n\nSuch reviews do not provide confidence that there will\n\nbe a second person who understands the\n\ncode change (e.g., if the originator suddenly becomes unavailable).\n\nHowever, analysis by bots\n\nmay be able to meet (at least in part) the [SAST](#sast) criterion.\n\n\n\nNote: Requiring reviews for all changes is infeasible for some projects, such as\n\nthose with only one active participant. Even a project with multiple active\n\ncontributors may not have enough active participation to be able to require\n\nreview of all proposed changes. Projects with a small number of active\n\nparticipants instead sometimes aim for a review of a\n\npercentage of proposals (e.g., \"at least half of all proposed changes are\n\nreviewed\").\n\n\n\nRequiring review does not eliminate all risks. The other reviewers might fail to\n\nnotice unintentional vulnerabilities or malicious code, be colluding with a\n\nmalicious developer, or even be the same person (using a \"[sock\n\npuppet](https://en.wikipedia.org/wiki/Sock_puppet_account)\" account).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#code-review",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/online-scm",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: found 30 unreviewed changesets out of 30 -- score normalized to 0\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "no file associated with this alert",
                "start_line": 1,
                "end_line": 1,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/61/instances"
    },
    {
        "number": 60,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/60",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/60",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "CIIBestPracticesID",
            "severity": "error",
            "description": "CII-Best-Practices",
            "name": "CII-Best-Practices",
            "tags": [
                "security",
                "security-awareness",
                "security-training"
            ],
            "full_description": "Determines if the project has an OpenSSF (formerly CII) Best Practices Badge.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- Sign up for the [OpenSSF Best Practices program](https://www.bestpractices.dev/).\n\n\n\n**Severity**: Low\n\n\n\n**Details**:\n\nRisk: `Low` (possibly not following security best practices)\n\n\n\nThis check determines whether the project has earned an [OpenSSF (formerly CII) Best Practices Badge](https://www.bestpractices.dev/) at the passing, silver, or gold level.\n\nThe OpenSSF Best Practices badge indicates whether or not that the project uses a set of security-focused best development practices for open\n\nsource software. The check uses the URL for the Git repo and the OpenSSF Best Practices badge API.\n\n\n\nThe OpenSSF Best Practices badge has 3 tiers: passing, silver, and gold. We give\n\nfull credit to projects that meet the [gold criteria](https://www.bestpractices.dev/criteria/2), which is a significant achievement for projects and requires multiple developers in the project.\n\nLower scores represent a project that has met the silver criteria, met the passing criteria, or is working to achieve the passing badge, with increasingly more points awarded as more criteria are met. Note that even meeting the passing criteria is a significant achievement.\n\n\n\n- [gold badge](https://www.bestpractices.dev/criteria/2): 10\n\n- [silver badge](https://www.bestpractices.dev/criteria/1): 7\n\n- [passing badge](https://www.bestpractices.dev/criteria/0): 5\n\n- in progress badge: 2\n\n\n\nSome of these criteria overlap with other Scorecard checks.\n\nHowever, note that in those overlapping cases, Scorecard can only report what it can automatically detect, while the OpenSSF Best Practices badge can report on claims and claim justifications from people (this counters false negatives and positives but has the challenge of requiring additional work from people).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#cii-best-practices",
            "security_severity_level": "low"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/online-scm",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: no effort to earn an OpenSSF best practices badge detected\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "no file associated with this alert",
                "start_line": 1,
                "end_line": 1,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/60/instances"
    },
    {
        "number": 59,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/59",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/59",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "TokenPermissionsID",
            "severity": "error",
            "description": "Token-Permissions",
            "name": "Token-Permissions",
            "tags": [
                "infrastructure",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project's workflows follow the principle of least privilege.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- Set top-level permissions as `read-all` or `contents: read` as described in GitHub's [documentation](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#permissions).\n\n- Set any required write permissions at the job-level. Only set the permissions required for that job; do not set `permissions: write-all` at the job level.\n\n- To help determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Restrict permissions for GITHUB_TOKEN\". You may also tick the \"Pin actions to a full length commit SHA\" to fix issues found by the Pinned-dependencies check.\n\n\n\n**Severity**: High\n\n\n\n**Details**:\n\nRisk: `High` (vulnerable to malicious code additions)\n\n\n\nThis check determines whether the project's automated workflows tokens follow the\n\nprinciple of least privilege. This is important because attackers may use a\n\ncompromised token with write access to, for example, push malicious code into the\n\nproject.\n\n\n\nIt is currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe highest score is awarded when the permissions definitions in each workflow's\n\nyaml file are set as read-only at the\n\n[top level](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#permissions)\n\nand the required write permissions are declared at the\n\n[run-level](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idpermissions).\n\nOne point is reduced from the score if all jobs have their permissions defined but the top level permissions are not defined.\n\nThis configuration is secure, but there is a chance that when a new job is added to the workflow, its job permissions could be\n\nleft undefined because of human error.\n\n\n\nThough a project's score won't be penalized, the check's details will include\n\nwarnings for more sensitive run-level permissions, listed below:\n\n\n\n* `actions` - May allow an attacker to steal GitHub secrets by approving to run an action that needs approval.\n\n* `checks` - May allow an attacker to remove pre-submit checks and introduce a bug.\n\n* `contents` - Allows an attacker to commit unreviewed code. However, points are not reduced if the job utilizes a recognized packaging action or command.\n\n* `deployments` - May allow an attacker to charge repo owner by triggering VM runs, and tiny chance an attacker can trigger a remote service with code they own if server accepts code/location variables unsanitized.\n\n* `packages` - Allows an attacker to publish packages. However, points are not reduced if the job utilizes a recognized packaging action or command.\n\n* `security-events` - May allow an attacker to read vulnerability reports before a patch is available. However, points are not reduced if the job utilizes a recognized action for uploading SARIF results.\n\n* `statuses` - May allow an attacker to change the result of pre-submit checks and get a PR merged.\n\n\n\nThis compromise makes it clear the maintainer has done what's possible to use those permissions safety,\n\nbut allows users to identify that the permissions are used.\n\n\n\nThe check cannot detect if the \"read-only\" GitHub permission setting is\n\nenabled, as there is no API available.\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#token-permissions",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 0: topLevel 'contents' permission set to 'write'\nRemediation tip: Visit [https://app.stepsecurity.io/secureworkflow](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/update_rapids.yml/master?enable=permissions).\nTick the 'Restrict permissions for GITHUB_TOKEN'\nUntick other options\nNOTE: If you want to resolve multiple issues at once, you can visit [https://app.stepsecurity.io/securerepo](https://app.stepsecurity.io/securerepo) instead.\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/update_rapids.yml",
                "start_line": 10,
                "end_line": 10,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/59/instances"
    },
    {
        "number": 58,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/58",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/58",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "TokenPermissionsID",
            "severity": "error",
            "description": "Token-Permissions",
            "name": "Token-Permissions",
            "tags": [
                "infrastructure",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project's workflows follow the principle of least privilege.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- Set top-level permissions as `read-all` or `contents: read` as described in GitHub's [documentation](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#permissions).\n\n- Set any required write permissions at the job-level. Only set the permissions required for that job; do not set `permissions: write-all` at the job level.\n\n- To help determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Restrict permissions for GITHUB_TOKEN\". You may also tick the \"Pin actions to a full length commit SHA\" to fix issues found by the Pinned-dependencies check.\n\n\n\n**Severity**: High\n\n\n\n**Details**:\n\nRisk: `High` (vulnerable to malicious code additions)\n\n\n\nThis check determines whether the project's automated workflows tokens follow the\n\nprinciple of least privilege. This is important because attackers may use a\n\ncompromised token with write access to, for example, push malicious code into the\n\nproject.\n\n\n\nIt is currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe highest score is awarded when the permissions definitions in each workflow's\n\nyaml file are set as read-only at the\n\n[top level](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#permissions)\n\nand the required write permissions are declared at the\n\n[run-level](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idpermissions).\n\nOne point is reduced from the score if all jobs have their permissions defined but the top level permissions are not defined.\n\nThis configuration is secure, but there is a chance that when a new job is added to the workflow, its job permissions could be\n\nleft undefined because of human error.\n\n\n\nThough a project's score won't be penalized, the check's details will include\n\nwarnings for more sensitive run-level permissions, listed below:\n\n\n\n* `actions` - May allow an attacker to steal GitHub secrets by approving to run an action that needs approval.\n\n* `checks` - May allow an attacker to remove pre-submit checks and introduce a bug.\n\n* `contents` - Allows an attacker to commit unreviewed code. However, points are not reduced if the job utilizes a recognized packaging action or command.\n\n* `deployments` - May allow an attacker to charge repo owner by triggering VM runs, and tiny chance an attacker can trigger a remote service with code they own if server accepts code/location variables unsanitized.\n\n* `packages` - Allows an attacker to publish packages. However, points are not reduced if the job utilizes a recognized packaging action or command.\n\n* `security-events` - May allow an attacker to read vulnerability reports before a patch is available. However, points are not reduced if the job utilizes a recognized action for uploading SARIF results.\n\n* `statuses` - May allow an attacker to change the result of pre-submit checks and get a PR merged.\n\n\n\nThis compromise makes it clear the maintainer has done what's possible to use those permissions safety,\n\nbut allows users to identify that the permissions are used.\n\n\n\nThe check cannot detect if the \"read-only\" GitHub permission setting is\n\nenabled, as there is no API available.\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#token-permissions",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 9: no topLevel permission defined\nRemediation tip: Visit [https://app.stepsecurity.io/secureworkflow](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/codeql.yml/master?enable=permissions).\nTick the 'Restrict permissions for GITHUB_TOKEN'\nUntick other options\nNOTE: If you want to resolve multiple issues at once, you can visit [https://app.stepsecurity.io/securerepo](https://app.stepsecurity.io/securerepo) instead.\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/codeql.yml",
                "start_line": 1,
                "end_line": 1,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/58/instances"
    },
    {
        "number": 57,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/57",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/57",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": ".github/workflows/python_wheels.yml",
                "start_line": 47,
                "end_line": 47,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/57/instances"
    },
    {
        "number": 56,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/56",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/56",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": ".github/workflows/python_tests.yml",
                "start_line": 342,
                "end_line": 342,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/56/instances"
    },
    {
        "number": 55,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/55",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/55",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": ".github/workflows/python_tests.yml",
                "start_line": 339,
                "end_line": 339,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/55/instances"
    },
    {
        "number": 54,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/54",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/54",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": ".github/workflows/python_tests.yml",
                "start_line": 298,
                "end_line": 298,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/54/instances"
    },
    {
        "number": 53,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/53",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/53",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": ".github/workflows/python_tests.yml",
                "start_line": 248,
                "end_line": 248,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/53/instances"
    },
    {
        "number": 52,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/52",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/52",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": ".github/workflows/python_tests.yml",
                "start_line": 157,
                "end_line": 157,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/52/instances"
    },
    {
        "number": 51,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/51",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/51",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": ".github/workflows/python_tests.yml",
                "start_line": 111,
                "end_line": 111,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/51/instances"
    },
    {
        "number": 50,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/50",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/50",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": ".github/workflows/python_tests.yml",
                "start_line": 73,
                "end_line": 73,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/50/instances"
    },
    {
        "number": 49,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/49",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/49",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": ".github/workflows/main.yml",
                "start_line": 187,
                "end_line": 187,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/49/instances"
    },
    {
        "number": 48,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/48",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/48",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/test_python.sh",
                "start_line": 31,
                "end_line": 31,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/48/instances"
    },
    {
        "number": 47,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/47",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/47",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/test_python.sh",
                "start_line": 22,
                "end_line": 22,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/47/instances"
    },
    {
        "number": 46,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/46",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/46",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/test_python.sh",
                "start_line": 17,
                "end_line": 17,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/46/instances"
    },
    {
        "number": 45,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/45",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/45",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/build_python_wheels.sh",
                "start_line": 68,
                "end_line": 68,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/45/instances"
    },
    {
        "number": 44,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/44",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/44",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.s390x",
                "start_line": 8,
                "end_line": 12,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/44/instances"
    },
    {
        "number": 43,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/43",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/43",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.jvm_gpu_build",
                "start_line": 39,
                "end_line": 40,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/43/instances"
    },
    {
        "number": 42,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/42",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/42",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: downloadThenRun not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.jvm_gpu_build",
                "start_line": 7,
                "end_line": 23,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/42/instances"
    },
    {
        "number": 41,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/41",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/41",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: downloadThenRun not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.jvm_gpu_build",
                "start_line": 7,
                "end_line": 23,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/41/instances"
    },
    {
        "number": 40,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/40",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/40",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.jvm_cross",
                "start_line": 35,
                "end_line": 36,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/40/instances"
    },
    {
        "number": 39,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/39",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/39",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.jvm_cross",
                "start_line": 9,
                "end_line": 30,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/39/instances"
    },
    {
        "number": 38,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/38",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/38",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: downloadThenRun not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.jvm_cross",
                "start_line": 9,
                "end_line": 30,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/38/instances"
    },
    {
        "number": 37,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/37",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/37",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.jvm",
                "start_line": 28,
                "end_line": 29,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/37/instances"
    },
    {
        "number": 36,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/36",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/36",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: downloadThenRun not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.jvm",
                "start_line": 4,
                "end_line": 20,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/36/instances"
    },
    {
        "number": 35,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/35",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/35",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: downloadThenRun not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.jvm",
                "start_line": 4,
                "end_line": 20,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/35/instances"
    },
    {
        "number": 34,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/34",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/34",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: downloadThenRun not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.gpu_build_centos7",
                "start_line": 8,
                "end_line": 21,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/34/instances"
    },
    {
        "number": 33,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/33",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/33",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.gpu_build_centos7",
                "start_line": 8,
                "end_line": 21,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/33/instances"
    },
    {
        "number": 32,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/32",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/32",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: downloadThenRun not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.gpu_build_centos7",
                "start_line": 8,
                "end_line": 21,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/32/instances"
    },
    {
        "number": 31,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/31",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/31",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: downloadThenRun not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.gpu",
                "start_line": 12,
                "end_line": 18,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/31/instances"
    },
    {
        "number": 30,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/30",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/30",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: downloadThenRun not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.cpu",
                "start_line": 8,
                "end_line": 16,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/30/instances"
    },
    {
        "number": 29,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/29",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/29",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: pipCommand not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.clang_tidy",
                "start_line": 26,
                "end_line": 27,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/29/instances"
    },
    {
        "number": 28,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/28",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/28",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: downloadThenRun not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.aarch64",
                "start_line": 6,
                "end_line": 14,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/28/instances"
    },
    {
        "number": 27,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/27",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/27",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: containerImage not pinned by hash\nRemediation tip: pin your Docker image by updating s390x/ubuntu:20.04 to s390x/ubuntu:20.04@sha256:88a3990f01d156a9cf839813b633b8dd046fbf17cb1d7fd35195275ba1361736\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.s390x",
                "start_line": 1,
                "end_line": 1,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/27/instances"
    },
    {
        "number": 26,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/26",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/26",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: containerImage not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.jvm_gpu_build",
                "start_line": 2,
                "end_line": 2,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/26/instances"
    },
    {
        "number": 25,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/25",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/25",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: containerImage not pinned by hash\nRemediation tip: pin your Docker image by updating ubuntu:18.04 to ubuntu:18.04@sha256:152dc042452c496007f07ca9127571cb9c29697f42acbfad72324b2bb2e43c98\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.jvm_cross",
                "start_line": 1,
                "end_line": 1,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/25/instances"
    },
    {
        "number": 24,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/24",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/24",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: containerImage not pinned by hash\nRemediation tip: pin your Docker image by updating centos:7 to centos:7@sha256:be65f488b7764ad3638f236b7b515b3678369a5124c47b8d32916d6487418ea4\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.jvm",
                "start_line": 1,
                "end_line": 1,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/24/instances"
    },
    {
        "number": 23,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/23",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/23",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: containerImage not pinned by hash\nRemediation tip: pin your Docker image by updating i386/debian:sid to i386/debian:sid@sha256:42e370abd2add69fad13a1a7de8786714a776bee87f0793773cf5c32b489ca18\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.i386",
                "start_line": 1,
                "end_line": 1,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/23/instances"
    },
    {
        "number": 22,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/22",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/22",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: containerImage not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.gpu_build_r_centos7",
                "start_line": 2,
                "end_line": 2,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/22/instances"
    },
    {
        "number": 21,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/21",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/21",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: containerImage not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.gpu_build_centos7",
                "start_line": 2,
                "end_line": 2,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/21/instances"
    },
    {
        "number": 20,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/20",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/20",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: containerImage not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.gpu",
                "start_line": 2,
                "end_line": 2,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/20/instances"
    },
    {
        "number": 19,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/19",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/19",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: containerImage not pinned by hash\nRemediation tip: pin your Docker image by updating ubuntu:22.04 to ubuntu:22.04@sha256:a6d2b38300ce017add71440577d5b0a90460d0e57fd7aec21dd0d1b0761bbfb2\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.cpu",
                "start_line": 1,
                "end_line": 1,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/19/instances"
    },
    {
        "number": 18,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/18",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/18",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: containerImage not pinned by hash\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.clang_tidy",
                "start_line": 2,
                "end_line": 2,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/18/instances"
    },
    {
        "number": 17,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/17",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/17",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: containerImage not pinned by hash\nRemediation tip: pin your Docker image by updating quay.io/pypa/manylinux2014_x86_64 to quay.io/pypa/manylinux2014_x86_64@sha256:b31275b340d8661e45a9eed29ca93d605a702557781fa65a7cb35bc9639165ad\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.auditwheel_x86_64",
                "start_line": 1,
                "end_line": 1,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/17/instances"
    },
    {
        "number": 16,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/16",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/16",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: containerImage not pinned by hash\nRemediation tip: pin your Docker image by updating quay.io/pypa/manylinux2014_aarch64 to quay.io/pypa/manylinux2014_aarch64@sha256:91f6c7954e938a66dfcb312f78a96d3c107c3ac1180c3801eec2bfb62dbe501b\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": "tests/ci_build/Dockerfile.aarch64",
                "start_line": 1,
                "end_line": 1,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": [
                "test"
            ]
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/16/instances"
    },
    {
        "number": 15,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/15",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/15",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: third-party GitHubAction not pinned by hash\nRemediation tip: update your workflow using [https://app.stepsecurity.io](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/update_rapids.yml/master?enable=pin)\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/update_rapids.yml",
                "start_line": 35,
                "end_line": 35,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/15/instances"
    },
    {
        "number": 14,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/14",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/14",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: GitHub-owned GitHubAction not pinned by hash\nRemediation tip: update your workflow using [https://app.stepsecurity.io](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/update_rapids.yml/master?enable=pin)\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/update_rapids.yml",
                "start_line": 28,
                "end_line": 28,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/14/instances"
    },
    {
        "number": 13,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/13",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/13",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: third-party GitHubAction not pinned by hash\nRemediation tip: update your workflow using [https://app.stepsecurity.io](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/r_tests.yml/master?enable=pin)\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/r_tests.yml",
                "start_line": 140,
                "end_line": 140,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/13/instances"
    },
    {
        "number": 12,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/12",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/12",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: third-party GitHubAction not pinned by hash\nRemediation tip: update your workflow using [https://app.stepsecurity.io](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/r_tests.yml/master?enable=pin)\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/r_tests.yml",
                "start_line": 92,
                "end_line": 92,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/12/instances"
    },
    {
        "number": 11,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/11",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/11",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: third-party GitHubAction not pinned by hash\nRemediation tip: update your workflow using [https://app.stepsecurity.io](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/python_wheels.yml/master?enable=pin)\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/python_wheels.yml",
                "start_line": 31,
                "end_line": 31,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/11/instances"
    },
    {
        "number": 10,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/10",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/10",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: GitHub-owned GitHubAction not pinned by hash\nRemediation tip: update your workflow using [https://app.stepsecurity.io](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/python_tests.yml/master?enable=pin)\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/python_tests.yml",
                "start_line": 221,
                "end_line": 221,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/10/instances"
    },
    {
        "number": 9,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/9",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/9",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: GitHub-owned GitHubAction not pinned by hash\nRemediation tip: update your workflow using [https://app.stepsecurity.io](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/python_tests.yml/master?enable=pin)\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/python_tests.yml",
                "start_line": 312,
                "end_line": 312,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/9/instances"
    },
    {
        "number": 8,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/8",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/8",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: GitHub-owned GitHubAction not pinned by hash\nRemediation tip: update your workflow using [https://app.stepsecurity.io](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/python_tests.yml/master?enable=pin)\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/python_tests.yml",
                "start_line": 273,
                "end_line": 273,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/8/instances"
    },
    {
        "number": 7,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/7",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/7",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: third-party GitHubAction not pinned by hash\nRemediation tip: update your workflow using [https://app.stepsecurity.io](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/i386.yml/master?enable=pin)\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/i386.yml",
                "start_line": 30,
                "end_line": 30,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/7/instances"
    },
    {
        "number": 6,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/6",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/6",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: third-party GitHubAction not pinned by hash\nRemediation tip: update your workflow using [https://app.stepsecurity.io](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/i386.yml/master?enable=pin)\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/i386.yml",
                "start_line": 26,
                "end_line": 26,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/6/instances"
    },
    {
        "number": 5,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/5",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/5",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: GitHub-owned GitHubAction not pinned by hash\nRemediation tip: update your workflow using [https://app.stepsecurity.io](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/i386.yml/master?enable=pin)\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/i386.yml",
                "start_line": 22,
                "end_line": 22,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/5/instances"
    },
    {
        "number": 4,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/4",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/4",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: GitHub-owned GitHubAction not pinned by hash\nRemediation tip: update your workflow using [https://app.stepsecurity.io](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/codeql.yml/master?enable=pin)\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/codeql.yml",
                "start_line": 95,
                "end_line": 95,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/4/instances"
    },
    {
        "number": 3,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-19T02:18:56Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/3",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/3",
        "state": "fixed",
        "fixed_at": "2024-05-19T02:18:53Z",
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "fixed",
            "commit_sha": "8e3f036b52dd6733255af001c373e6e29c70ca10",
            "message": {
                "text": "score is 2: GitHub-owned GitHubAction not pinned by hash\nRemediation tip: update your workflow using [https://app.stepsecurity.io](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/codeql.yml/master?enable=pin)\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/codeql.yml",
                "start_line": 67,
                "end_line": 67,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/3/instances"
    },
    {
        "number": 2,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:20Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/2",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/2",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "PinnedDependenciesID",
            "severity": "error",
            "description": "Pinned-Dependencies",
            "name": "Pinned-Dependencies",
            "tags": [
                "dependencies",
                "security",
                "supply-chain"
            ],
            "full_description": "Determines if the project has declared and pinned the dependencies of its build process.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- If your project is producing an application, declare all your dependencies with specific versions in your package format file (e.g. `package.json` for npm, `requirements.txt` for python, `packages.config` for nuget). For C/C++, check in the code from a trusted source and add a `README` on the specific version used (and the archive SHA hashes).\n\n- If your project is producing an application and the package manager supports lock files (e.g. `package-lock.json` for npm), make sure to check these in the source code as well. These files maintain signatures for the entire dependency tree and saves from future exploitation in case the package is compromised.\n\n- For Dockerfiles used in building and releasing your project, pin dependencies by hash. See [Dockerfile](https://github.com/ossf/scorecard/blob/main/cron/internal/worker/Dockerfile) for example. If you are using a manifest list to support builds across multiple architectures, you can pin to the manifest list hash instead of a single image hash. You can use a tool like [crane](https://github.com/google/go-containerregistry/blob/main/cmd/crane/README.md) to obtain the hash of the manifest list like in this [example](https://github.com/ossf/scorecard/issues/1773#issuecomment-1076699039).\n\n- For GitHub workflows used in building and releasing your project, pin dependencies by hash. See [main.yaml](https://github.com/ossf/scorecard/blob/f55b86d6627cc3717e3a0395e03305e81b9a09be/.github/workflows/main.yml#L27) for example. To determine the permissions needed for your workflows, you may use [StepSecurity's online tool](https://app.stepsecurity.io/secureworkflow/) by ticking the \"Pin actions to a full length commit SHA\". You may also tick the \"Restrict permissions for GITHUB_TOKEN\" to fix issues found by the Token-Permissions check.\n\n- To help update your dependencies after pinning them, use tools such as those listed for the dependency update tool check.\n\n\n\n**Severity**: Medium\n\n\n\n**Details**:\n\nRisk: `Medium` (possible compromised dependencies)\n\n\n\nThis check tries to determine if the project pins dependencies used during its build and release process.\n\nA \"pinned dependency\" is a dependency that is explicitly set to a specific hash instead of\n\nallowing a mutable version or range of versions. It\n\nis currently limited to repositories hosted on GitHub, and does not support\n\nother source hosting repositories (i.e., Forges).\n\n\n\nThe check works by looking for unpinned dependencies in Dockerfiles, shell scripts, and GitHub workflows\n\nwhich are used during the build and release process of a project.\n\nSpecial considerations for Go modules treat full semantic versions as pinned\n\ndue to how the Go tool verifies downloaded content against the hashes when anyone first downloaded the module.\n\n\n\nPinned dependencies reduce several security risks:\n\n\n\n  - They ensure that checking and deployment are all done with the same\n\n    software, reducing deployment risks, simplifying debugging, and enabling\n\n    reproducibility.\n\n  - They can help mitigate compromised dependencies from undermining the\n\n    security of the project (in the case where you've evaluated the pinned\n\n    dependency, you are confident it's not compromised, and a later version is\n\n    released that is compromised).\n\n  - They are one way to [counter dependency confusion (aka substitution) attacks](https://azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/),\n\n    in which an application uses multiple feeds to acquire software packages (a\n\n    \"hybrid configuration\"), and attackers fool the user into using a malicious\n\n    package via a feed that was not expected for that package.\n\n\n\nHowever, pinning dependencies can inhibit software updates, either because of a\n\nsecurity vulnerability or because the pinned version is compromised. Mitigate\n\nthis risk by:\n\n\n\n  - using automated tools to notify applications when their dependencies are\n\n    outdated;\n\n  - quickly updating applications that do pin dependencies.\n\n\n\nFor projects hosted on GitHub, you can learn more about\n\ndependencies using the [GitHub dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#pinned-dependencies",
            "security_severity_level": "medium"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/local",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: GitHub-owned GitHubAction not pinned by hash\nRemediation tip: update your workflow using [https://app.stepsecurity.io](https://app.stepsecurity.io/secureworkflow/fcas/xgboost/codeql.yml/master?enable=pin)\nClick Remediation section below for further remediation help"
            },
            "location": {
                "path": ".github/workflows/codeql.yml",
                "start_line": 63,
                "end_line": 63,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/2/instances"
    },
    {
        "number": 1,
        "created_at": "2024-05-17T04:27:19Z",
        "updated_at": "2024-05-17T04:27:19Z",
        "url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/1",
        "html_url": "https://github.com/fcas/xgboost/security/code-scanning/1",
        "state": "open",
        "fixed_at": null,
        "dismissed_by": null,
        "dismissed_at": null,
        "dismissed_reason": null,
        "dismissed_comment": null,
        "rule": {
            "id": "BranchProtectionID",
            "severity": "error",
            "description": "Branch-Protection",
            "name": "Branch-Protection",
            "tags": [
                "code-reviews",
                "security",
                "source-code",
                "supply-chain"
            ],
            "full_description": "Determines if the default and release branches are protected with GitHub's branch protection settings.",
            "help": "**Remediation (click \"Show more\" below)**:\n\n- Enable branch protection settings in your source hosting provider to avoid force pushes or deletion of your important branches.\n\n- For GitHub, check out the steps [here](https://docs.github.com/en/github/administering-a-repository/managing-a-branch-protection-rule).\n\n\n\n**Severity**: High\n\n\n\n**Details**:\n\nRisk: `High` (vulnerable to intentional malicious code injection)\n\n\n\nThis check determines whether a project's default and release branches are\n\nprotected with GitHub's [branch protection](https://docs.github.com/github/administering-a-repository/defining-the-mergeability-of-pull-requests/about-protected-branches) \n\nor [repository rules](https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/about-rulesets) settings.\n\nBranch protection allows maintainers to define rules that enforce\n\ncertain workflows for branches, such as requiring review or passing certain\n\nstatus checks before acceptance into a main branch, or preventing rewriting of\n\npublic history.\n\n\n\nNote: The following settings queried by the Branch-Protection check require an admin token: `DismissStaleReviews`, `EnforceAdmins`, `RequireLastPushApproval`, `RequiresStatusChecks` and `UpToDateBeforeMerge`. If\n\nthe provided token does not have admin access, the check will query the branch\n\nsettings accessible to non-admins and provide results based only on these settings.\n\nHowever, all of these settings are accessible via Repo Rules. `EnforceAdmins` is calculated slightly differently.\n\nThis setting is calculated as `false` if any [Bypass Actors](https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/creating-rulesets-for-a-repository#granting-bypass-permissions-for-your-ruleset)\n\n are defined on any rule, regardless of if they are admins.\n\n\n\nDifferent types of branch protection protect against different risks:\n\n\n\n  - Require code review: \n\n    - requires at least one reviewer, which greatly\n\n    reduces the risk that a compromised contributor can inject malicious code.\n\n    Review also increases the likelihood that an unintentional vulnerability in\n\n    a contribution will be detected and fixed before the change is accepted.\n\n\n\n    - requiring two or more reviewers protects even more from the insider risk \n\n    whereby a compromised contributor can be used by an attacker to LGTM \n\n    the attacker PR and inject a malicious code as if it was legit.\n\n\n\n  - Prevent force push: prevents use of the `--force` command on public\n\n    branches, which overwrites code irrevocably. This protection prevents the\n\n    rewriting of public history without external notice.\n\n\n\n  - Require [status checks](https://docs.github.com/en/github/collaborating-with-pull-requests/collaborating-on-repositories-with-code-quality-features/about-status-checks):\n\n    ensures that all required CI tests are met before a change is accepted.\n\n\n\nAlthough requiring code review can greatly reduce the chance that\n\nunintentional or malicious code enters the \"main\" branch, it is not feasible for\n\nall projects, such as those that don't have many active participants. For more\n\ndiscussion, see [Code Reviews](https://github.com/ossf/scorecard/blob/main/docs/checks.md#code-review).\n\n\n\nAdditionally, in some cases these rules will need to be suspended. For example,\n\nif a past commit includes illegal content such as child pornography, it may be\n\nnecessary to use a force push to rewrite the history rather than simply hide the\n\ncommit.\n\n\n\nThis test has tiered scoring. Each tier must be fully satisfied to achieve points at the next tier. For example, if you fulfill the Tier 3 checks but do not fulfill all the Tier 2 checks, you will not receive any points for Tier 3.\n\n\n\nNote: If Scorecard is run without an administrative access token, the requirements that specify For administrators can be safely ignored, and scores will be determined as if all such requirements have been met.\n\n\n\nTier 1 Requirements (3/10 points):\n\n  - Prevent force push\n\n  - Prevent branch deletion\n\n\n\nTier 2 Requirements (6/10 points):\n\n  - Require at least 1 reviewer for approval before merging\n\n  - For administrators: Require branch to be up to date before merging\n\n  - For administrators: Require approval of the most recent reviewable push\n\n\n\nTier 3 Requirements (8/10 points):\n\n  - Require branch to pass at least 1 status check before merging\n\n\n\nTier 4 Requirements (9/10 points):\n\n  - Require at least 2 reviewers for approval before merging\n\n  - Require review from code owners\n\n\n\nTier 5 Requirements (10/10 points):\n\n  - For administrators: Dismiss stale reviews and approvals when new commits are pushed\n\n  - For administrators: Include administrator for review\n\n\n\nGitLab Integration Status:\n\n  - GitLab associates releases with commits and not with the branch. Releases are ignored in this portion of the scoring.\n\n",
            "help_uri": "https://github.com/ossf/scorecard/blob/49c0eed3a423f00c872b5c3c9f1bbca9e8aae799/docs/checks.md#branch-protection",
            "security_severity_level": "high"
        },
        "tool": {
            "name": "Scorecard",
            "guid": null,
            "version": "v4.13.1"
        },
        "most_recent_instance": {
            "ref": "refs/heads/master",
            "analysis_key": ".github/workflows/scorecards.yml:analysis",
            "environment": "{}",
            "category": "supply-chain/branch-protection",
            "state": "open",
            "commit_sha": "8735cd89785241c02fc4115f745609fe9b4a52dc",
            "message": {
                "text": "score is 0: branch protection not enabled on development/release branches:\nWarn: branch protection not enabled for branch 'master'\nClick Remediation section below to solve this issue"
            },
            "location": {
                "path": "no file associated with this alert",
                "start_line": 1,
                "end_line": 1,
                "start_column": 1,
                "end_column": 0
            },
            "classifications": []
        },
        "instances_url": "https://api.github.com/repos/fcas/xgboost/code-scanning/alerts/1/instances"
    }
]